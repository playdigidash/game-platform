import { __awaiter } from "tslib";
// Define the enum here in case we can't import it
export var EObstacleModelType;
(function (EObstacleModelType) {
    EObstacleModelType[EObstacleModelType["dodge"] = 0] = "dodge";
    EObstacleModelType[EObstacleModelType["jump"] = 1] = "jump";
    EObstacleModelType[EObstacleModelType["slide"] = 2] = "slide";
    EObstacleModelType[EObstacleModelType["sponsor"] = 3] = "sponsor";
    EObstacleModelType[EObstacleModelType["question"] = 4] = "question";
    EObstacleModelType[EObstacleModelType["hint"] = 5] = "hint";
    EObstacleModelType[EObstacleModelType["coin"] = 6] = "coin";
})(EObstacleModelType || (EObstacleModelType = {}));
// This will be auto-generated by wasm-pack
import init, { ObstaclePool, js_enum_to_obstacle_type, } from '../pkg/obstacle_pool_wasm';
export class RustObstaclePool {
    constructor() {
        this.wasmPool = null;
        this.instanceMap = new Map();
        this.initialized = false;
        this.instanceCounter = 0;
        // Initialize WebAssembly module
        this.readyPromise = this.initialize();
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield init();
                this.wasmPool = new ObstaclePool();
                this.initialized = true;
                console.log('Rust obstacle pool initialized successfully');
            }
            catch (error) {
                console.error('Failed to initialize Rust obstacle pool:', error);
                throw error;
            }
        });
    }
    // Wait for initialization to complete
    ready() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.readyPromise;
        });
    }
    // Convert TypeScript enum to Rust enum
    convertObstacleType(type) {
        return js_enum_to_obstacle_type(type);
    }
    // Add obstacles to the pool
    addToPool(threeJSInstance, type, id, isCustom) {
        if (!this.initialized || !this.wasmPool) {
            console.error('Rust obstacle pool not initialized');
            return;
        }
        // Store a reference to the ThreeJS object
        const instanceId = this.instanceCounter++;
        this.instanceMap.set(instanceId, threeJSInstance);
        // Add to Rust pool
        this.wasmPool.add_to_pool(this.convertObstacleType(type), instanceId, id, isCustom);
    }
    // Get an obstacle instance from the pool
    getInstance(type) {
        if (!this.initialized || !this.wasmPool) {
            console.error('Rust obstacle pool not initialized');
            return null;
        }
        const obstacleResult = this.wasmPool.get_instance(this.convertObstacleType(type));
        if (!obstacleResult) {
            return null;
        }
        const obstacle = obstacleResult;
        const threeJSInstance = this.instanceMap.get(obstacle.instance_ref);
        if (!threeJSInstance) {
            console.error(`Three.js instance not found for ref: ${obstacle.instance_ref}`);
            return null;
        }
        // Make the instance visible
        threeJSInstance.visible = obstacle.is_visible;
        return {
            id: obstacle.id,
            instance: threeJSInstance,
        };
    }
    // Return an obstacle to the pool
    returnToPool(id, instance) {
        if (!this.initialized || !this.wasmPool) {
            console.error('Rust obstacle pool not initialized');
            return false;
        }
        // Reset the ThreeJS object properties
        instance.position.set(0, 0, 0);
        instance.rotation.set(0, 0, 0);
        instance.visible = false;
        // Return to Rust pool
        return this.wasmPool.return_to_pool(id);
    }
    // Update position in both ThreeJS and Rust
    updatePosition(id, position) {
        if (!this.initialized || !this.wasmPool) {
            return false;
        }
        return this.wasmPool.update_position(id, position.x, position.y, position.z);
    }
    // Update rotation in both ThreeJS and Rust
    updateRotation(id, rotation) {
        if (!this.initialized || !this.wasmPool) {
            return false;
        }
        return this.wasmPool.update_rotation(id, rotation.x, rotation.y, rotation.z);
    }
    // Get pool size
    getPoolSize(type) {
        if (!this.initialized || !this.wasmPool) {
            return 0;
        }
        return this.wasmPool.get_pool_size(this.convertObstacleType(type));
    }
    // Clear the pool
    clearPool() {
        if (!this.initialized || !this.wasmPool) {
            return;
        }
        this.wasmPool.clear_pool();
        this.instanceMap.clear();
    }
}
// Create singleton instance
const rustObstaclePool = new RustObstaclePool();
// Export the instance and class
export { rustObstaclePool };
export default rustObstaclePool;
//# sourceMappingURL=index.js.map