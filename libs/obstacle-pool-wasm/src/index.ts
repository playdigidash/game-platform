// TypeScript wrapper for the Rust-based object pooling system
import * as THREE from 'three';

// Define the enum here in case we can't import it
export enum EObstacleModelType {
  dodge = 0,
  jump = 1,
  slide = 2,
  sponsor = 3,
  question = 4,
  hint = 5,
  coin = 6,
}

// This will be auto-generated by wasm-pack
import init, {
  ObstaclePool,
  ObstacleType,
  Vector3 as RustVector3,
  js_enum_to_obstacle_type,
} from '../pkg/obstacle_pool_wasm';

// We need to keep references to ThreeJS objects for rendering
type ThreeJSInstancesMap = Map<number, THREE.Group>;

export class RustObstaclePool {
  private wasmPool: ObstaclePool | null = null;
  private instanceMap: ThreeJSInstancesMap = new Map();
  private initialized = false;
  private instanceCounter = 0;
  private readyPromise: Promise<void>;

  constructor() {
    // Initialize WebAssembly module
    this.readyPromise = this.initialize();
  }

  private async initialize(): Promise<void> {
    try {
      await init();
      this.wasmPool = new ObstaclePool();
      this.initialized = true;
      console.log('Rust obstacle pool initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Rust obstacle pool:', error);
      throw error;
    }
  }

  // Wait for initialization to complete
  public async ready(): Promise<void> {
    return this.readyPromise;
  }

  // Convert TypeScript enum to Rust enum
  private convertObstacleType(type: EObstacleModelType): ObstacleType {
    return js_enum_to_obstacle_type(type as number);
  }

  // Add obstacles to the pool
  public addToPool(
    threeJSInstance: THREE.Group,
    type: EObstacleModelType,
    id: string,
    isCustom: boolean
  ): void {
    if (!this.initialized || !this.wasmPool) {
      console.error('Rust obstacle pool not initialized');
      return;
    }

    // Store a reference to the ThreeJS object
    const instanceId = this.instanceCounter++;
    this.instanceMap.set(instanceId, threeJSInstance);

    // Add to Rust pool
    this.wasmPool.add_to_pool(
      this.convertObstacleType(type),
      instanceId,
      id,
      isCustom
    );
  }

  // Get an obstacle instance from the pool
  public getInstance(type: EObstacleModelType): {
    id: number;
    instance: THREE.Group | null;
  } | null {
    if (!this.initialized || !this.wasmPool) {
      console.error('Rust obstacle pool not initialized');
      return null;
    }

    const obstacleResult = this.wasmPool.get_instance(
      this.convertObstacleType(type)
    );

    if (!obstacleResult) {
      return null;
    }

    const obstacle = obstacleResult as {
      id: number;
      instance_ref: number;
      is_visible: boolean;
    };

    const threeJSInstance = this.instanceMap.get(obstacle.instance_ref);

    if (!threeJSInstance) {
      console.error(
        `Three.js instance not found for ref: ${obstacle.instance_ref}`
      );
      return null;
    }

    // Make the instance visible
    threeJSInstance.visible = obstacle.is_visible;

    return {
      id: obstacle.id,
      instance: threeJSInstance,
    };
  }

  // Return an obstacle to the pool
  public returnToPool(id: number, instance: THREE.Group): boolean {
    if (!this.initialized || !this.wasmPool) {
      console.error('Rust obstacle pool not initialized');
      return false;
    }

    // Reset the ThreeJS object properties
    instance.position.set(0, 0, 0);
    instance.rotation.set(0, 0, 0);
    instance.visible = false;

    // Return to Rust pool
    return this.wasmPool.return_to_pool(id);
  }

  // Update position in both ThreeJS and Rust
  public updatePosition(id: number, position: THREE.Vector3): boolean {
    if (!this.initialized || !this.wasmPool) {
      return false;
    }

    return this.wasmPool.update_position(
      id,
      position.x,
      position.y,
      position.z
    );
  }

  // Update rotation in both ThreeJS and Rust
  public updateRotation(id: number, rotation: THREE.Euler): boolean {
    if (!this.initialized || !this.wasmPool) {
      return false;
    }

    return this.wasmPool.update_rotation(
      id,
      rotation.x,
      rotation.y,
      rotation.z
    );
  }

  // Get pool size
  public getPoolSize(type: EObstacleModelType): number {
    if (!this.initialized || !this.wasmPool) {
      return 0;
    }

    return this.wasmPool.get_pool_size(this.convertObstacleType(type));
  }

  // Clear the pool
  public clearPool(): void {
    if (!this.initialized || !this.wasmPool) {
      return;
    }

    this.wasmPool.clear_pool();
    this.instanceMap.clear();
  }
}

// Create singleton instance
const rustObstaclePool = new RustObstaclePool();

// Export the instance and class
export { rustObstaclePool };
export default rustObstaclePool;
